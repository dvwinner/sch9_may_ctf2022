# Разбор таски кк
Вспомним таску. Дана программа на python3, которая бесконечно работает и тратит всю оперативную память компьютера. Что она бы вывела если бы мы запустили её на компьютере с достаточно большим кол-вом памяти и подождали достаточно долго?
Код:
```python
#!/bin/python3

import itertools
n=1000000
mod=int(1e9+7)
print('ctf{'+str((len(list(itertools.permutations(range(n)))))%mod)+'}')
```
Разбор:\
*Решение 1*.\
Заметим что первая строка это комментарий (точнее, это шебанг, но для таски это не важно), вторая строка - импорт нужной библиотеки, третья и четвёртая задают переменную и только в последней происходит что-то функциональное. По сути, основная программа именно в ней, так что давайте разберём что она делает. range(n) - функция, создающая объект range с элементами от 0 до n-1. Фактически, это аналогично списку чисел от 0 до n-1. Читая документация по библиотеке itertools, мы узнаём что itertools генерирует все перестановки из массива, причем два одинаковых элемента под разным номером считаются за разные. Из массива [1,2] функция сгенерирует ((1,2),(2,1)) (то что скобки круглые неважно, это практически другой вид массивов в python). Дальше, мы преобразуем ответ функции к типу list и берём len от полученного, фактически мы просто узнаём кол-во перестановок массива [0,1,2,...,n-1]. Это значение можно посчитать как 1\*2\*3\*...\*n, что нетрудно доказать. Данная запись (1\*2\*3\*...\*n) в математике называется факториал. Таким образом, мы получаем что все эти функции просто считали факториал от n, а потом брали его по модулю mod, который нам известен. Так мы получаем что код можно заменить следующим кодом:

```python
from math import factorial
n=1000000
mod=int(1e9+7)
print('ctf{'+str(factorial(n)%mod)+'}')
```

*Решение 2*.\
Переменная n задана очень большой. Давайте уменьшим её. При значениях до 10 программа работает не очень долго, причем по полученным значениям можно догадаться что результат - факториал n, взятый по модулю mod. Проверяем предположение, таска заходит. profit.